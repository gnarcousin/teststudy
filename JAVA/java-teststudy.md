<h1>자바</h1>

<h2>1장 - 기본코드</h2>

> - 자바는 **대소문자를 구분**한다.
> - 자바는 문장을 세미콜론(;)으로 구분함

```java
public class 파일명{
    public static void main(String[] args){  //자바 프로그램을 실행하는 main 메소드 
        
    }
}

System.out.println("자료값"); /* 콘솔의 여러 자료 값을 한 행에 출력하는 명령어 */
```

<h2>2장 section1 - 자바 프로그래밍 기초 </h2>

> - 클래스 = 자바의 프로그램 단위. 대소문자를 구분하며 public인 경우 반드시 파일 이름과 일치해야 함
> - 패키지 = 관련된 다양한 자바 클래스가 모여있는 폴더
  
> - 자바의 클래스 내부는 필드와 메소드로 구분됨
>> - 필드 = 소속변수 (대부분 메소드에서 사용 가능)
>> - 메소드 = 절차지향 언어의 함수와 같은 역할을 수행함
>>> - main() 메소드 = 자바 프로그램이 실행되는 문장이 기술됨
> - 클래스 구조

```java
public class 클래스명 {
    static String fd = "-- 필드"; //필드 (소속 변수) 선언

    public static void main(String[] args) { // 메소드 헤드 = '수정자 반환형 메소드이름(인자목록)' 형식으로 메소드의 특성 표현
        System.out.println("자바 클래스의 구조");
        write(fd); //write()의 메소드 호출

        //이 공간은 중괄호로 구성된 메소드 블록임
        //여기서 메소드가 구현됨(정의)

    }

    //프로그래머가 정의하는 메소드 write() 구현
    public static void write(String word) {
        System.out.println(word); //write()가 호출받으면 메소드 블록을 실행한 뒤 다시 main()으로 돌아감
    }
}
```

> - **키워드**
> - 문법적으로 의미 이있는 단어로 사용하기 위해 미리 정의해놓은 단어
> 
> |키워드|48가지|goto와|const는|실제로는|사용 안함|---|
> |---|---|---|---|---|---|---|
> |abstract|class|extends|import|private|switch|volitile|
> |assert|const|final|instanceof|protected|synchronized|while|
> |boolean|continue|finally|int|public|this|---|
> |break|default|float|interface|return|throw|---|
> |byte|do|for|long|short|throws|---|
> |case|double|goto|native|static|transient|---|
> |catch|else|if|new|strictfp|try|---|
> |char|enum|implements|package|super|void|---|

> - **식별자**
> - 프로그래머가 정의하여 사용하는 단어
> - **규칙**
> <pre>
> 1. 키워드는 식별자로 이용 불가능
> 2. 식별자의 첫 문자로 숫자 사용 불가능
> 3. 식별자는 대소문자를 구분하고, 중간에 공백 문자를 넣을 수 없음
> 4. 유니코드를 지원해 한글 사용은 가능하나 권장하지 않음
> </pre>

<h1>2장 section2 - 자바의 자료형</h1>

> - 자료형의 분류
>
> |구분|분류|키워드|
> |---|---|---|
> |기본형|논리형|boolean|
> ||문자형|char|
> ||정수형|byte, short, int, long|
> ||실수형|float, double|
> |참조형|배열|int [], float [] 등 다양|
> ||클래스|String, Date 등 다양|
> ||인터페이스|Runnable, Enumeration 등 다양|
> - 기본형은 변수의 저장공간에 **값 자체**가 저장
> - 참조형은 변수의 저장공간에 **참조값**이 저장됨

> - 자료형의 크기
> 
> |분류|키워드|크기|상대적 크기 비교|최소 ~ 최대|지수형태 범위|
> |---|---|---|---|---|---|
> |논리형|boolean|1바이트|■|false, true||
> |문자형|char|2바이트|■■|\u0000 ~ \uffff, [0 ~ 65,535]|0 ~ 2^16-1|
> |정수형|byte|1바이트|■|-128 ~ 127|-2^7 ~ 2^7-1|
> ||short|2바이트|■■|-32,767 ~ 32,767|-2^15 ~ 2^15-1|
> ||int|4바이트|■■■■|-2,147,483,648 ~ 2,147,483,647|-2^31 ~ 2^31-1|
> ||long|8바이트|■■■■■■■■|-2^63 ~ 2^63-1|-2^63 ~ 2^63-1|
> |실수형|float|4바이트|■■■■|(+,-)1.4E-45 ~ 3.4028235E38||
> ||double|8바이트|■■■■■■■■|(+,-)4.9E-324 ~ 1.7976931348623157E308||
> - 정수와 실수를 표현하는 자료형이 다양한 이유는 그 표현 범위가 다르기 때문

> - 상수
> - 소스에 그대로 표현 가능한 다양한 자료 값
> -정수 상수에서 숫자 앞의 0은 8진수, 0x(0X)는 16진수 <br> 01로만 구성된 수 앞에 0b를 붙이면 이진수 표현 방법으로 사용 가능
> 
> |분류|자료형|상수|비고|
> |---|---|---|---|
> |논리형|boolean|false, true|2개 이외에는 없음|
> |문자형|char|'A','자','%','\\','\n','\23'(8진수 코드값), '\u2344'(16진수 코드 값)|작은 따옴표로 표기|
> |정수형|int|10, 45(십진수), 0b1010(이진수 1010), 020(8진수 20), 0x1d(16진수 1d|0X1D와 같이 대문자도 가능|
> ||long|32I,220000000L|정수 뒤에 I나 L 표기|
> |실수형|float|3.14f, 5.25F|e와 E 모두 가능 <br> 실수 뒤에 d나 D도 가능|
> ||double|2.98e2(2.98*10^2) <br> 5.8E-2(5.8 * 10^-2) <br> 3.75, 3.2d, 5.78D|''|
> |문자열|String|"문자의 모음"|큰 따옴표로 표기|
> - 숫자 상수 표현 중간의 밑줄(_)은 자릿수를 구분하는 구분자로 사용 가능

> - **변수** = 자료 값을 저장하는 공간
> - **자료형과 변수 이름**을 나열하고 대입연산자 = 을 이용해 값을 저장하는 형식
> - 하나의 변수선언 문장으로 여러개의 변수 선언이 가능함
> ```java
> int a, b, c; //여러 변수 선언
> int x, y = 3, x = 1; //부분적으로 초기값 대입
> int num1 = 30, num2 = 20; //모든 초기값 대입
> ```
> - 필드(소속변수)와 달리 지역변수는 변수 선언 시 **초기 값을 저장하지 않고 사용하면** 컴파일 오류가 발생함

<h1>2장 section3 - 자료의 입력과 출력</h1>

> - 클래스 java.util.Scanner = 사용자가 콘솔에 입력하는 값을 공백문자와 함께 ['\t','\f','\r','\n']으로 구분하여 입력받음
> ```java
> java.util.Scanner input = new java.util.Scanner(System.in);
> String name = input.next()
> ```
> - 메소드 종류
>
> |Scanner의 메소드|설명|
> |---|---|
> |String next()|토큰을 읽어 문자열로 반환|
> |int nextInt() <br> int nextInt(int radix)|다음 정수를 읽어 int로 반환<br> 다음 정수를 인자인 radix 진법으로 읽어 int로 반환|
> |long nextLong() <br> long nextLong(int radix)|다음 정수를 읽어 long으로 반환<br> 다음 정수를 인자인 radix 진법으로 읽어 long으로 반환|
> |float nextFloat() <br> double nextDouble()|다음 실수를 읽어 float으로 반환 <br> 다음 실수를 읽어 double로 반환|
> |String nextLine()|다음 줄의 내용을 모두 읽어 문자열로 반환|
> |boolean nextBoolean()|다음 논리 값을 읽어 boolean으로 반환|

> - **입출력 메소드**
> - 콘솔에 표준 출력하기 위해 **클래스 System의 필드 out**을 사용
>
> |필드선언|설명|사용법|
> |---|---|---|
> |static PrintStream err|표준 에러 출력 스트림|System.err|
> |static InputStream in|표준 입력 스트림|System.in|
> |static PrintStream out|표준 출력 스트림|System.out|
> 
> <br><br>
> - 메소드 **printf()**의 첫 번째 인자는 **형식 문자열(format string)**이며 내부의 %d는 이후 **인자의 값이 대체되어 출력되는 형식 지정자**임
> - **format() = printf()**
> ```java
> int num1= 23;
> int num2 = 1024;
> System.out.printf("num1 = %d, num2= %d", num1, num2);
> // num1 = 23, num2 = 1024
> ```
> - printf()(=format())의 형식 지정자
> 
> |출력 지정자|설명|
> |---|---|
> |%b %B|논리 값 출력|
> |%h %H|16진수로 출력|
> |%s %S|문자열 출력|
> |%c %C|문자 출력|
> |%d|십진수로 출력|
> |%o|8진수로 출력|
> |%x %X|16진수로 출력|
> |%f|실수로 출력|
> |%%|% 출력|
> |%n|새로운 줄(new line)으로 이동|
> - 형식지정자 **%x.yf** = 전체 폭이 x, 소수점 폭 y로 출력

> - **import 문장**
> - java.lang을 제외한 모든 패키지는 클래스 이름 앞에 모두 패키지 이름을 기술해야함 > **import**를 사용하면 기술할 필요 없어짐
> - 사용법
> 
> ```java
> import java.util.Scanner; // 클래스 이름을 패키지 이름과 함께 모두 기술함
> import java.util.*; // 패키지 이름 이후의 *은 해당 패키지의 모든 class를 사용하겠다는 의미
> ```

<h1>3장 section1 - 연산자 개요 </h1>

> - **연산자** = 이미 정의된 **연산을 수행**하는 문자 또는 문자 조합 기호
> - **피연산자** = 연산에 참여하는 **변수나 상수**
> - **표현식** = 연산자와 피연산자의 조합으로 구성된 **연산식**
> - 연산자의 종류 
> - 피연산자 수에 따라 **단항, 이항, 삼항 연산자**
> - 연산자 위치에 따라 **전위, 후위 연산자**
> - 자바는 우선순위에 따라 먼저 계산함
> 
> |우선순위|연산자 이름|연산자|연산방향|
> |---|---|:---:|---|
> |1|후위 단항|var++ var--||
> |2|전위 단항|++var --var +expr -expr ~ !||
> |3|곱셈 부류|* / %|
> |4|덧셈 부류|+ -|
> |5|비트 이동|<< >> >>>|
> |6|관계|< > <= >= instanceof|
> |7|동등|== !=|
> |8|비트 AND|&|
> |9|비트 배타적 OR|^|
> |10|비트 OR|\||
> |11|논리 AND|&&|
> |12|논리 OR|\|\||
> |13|조건 삼항|expr ? x : y|
> |14|대입|= += -= *= /= %= &= ^= \|= <<= >>= >>>=| <-
> - ※ 대입 연산자를 제외하면 왼쪽에서 오른쪽으로 연산함

> - **대입연산자** = 왼쪽 변수에 오른쪽 **값을 저장하는** 연산자
>> - 왼쪽은 반드시 값을 저장할 수 있는 변수여야 함
> - **부호 연산자** = 양수 / 음수 **부호 표시**
> - **산술 연산자** = **계산**을 해주는 연산자 (*+는 문자열 연결 연산자이기도 함*)
> - **축약 대입 연산자** = 대입 연산식을 **간결하게 표현**하는 연산자 (+=, -= 등)
> - **증가 연산자** = 변수 값을 **1 증가**시킴
> - **감소 연산자** = 변수 값을 **1 감소**시킴
>> - 둘 다 단항 연산자이다
>> - 전위 / 후위에 따라 연산 결과 값이 n±1 / n으로 나뉨
>> - 연산 후의 값은 전부 n±1이 됨
> - **조건 연산자** = **조건의 논리에 따라** 2개의 피연산자 중 하나가 결과 값이 되는 연산자
>> - 유일한 삼항 연산자임
>> - **x ? a : b** = x가 true면 a, false면 b를 의미함
> - **관계 연산자** = 2개의 **피연산자 크기를 비교**하는 연산자
>> - 결과값은 항상 **boolean값(true, false)**
> - **논리 연산자** = and, or, xor, not의 논리 연산
>> - 피연산자는 반드시 **boolean형(true, false)**여야 함
>> - 논리연산자 **&&와 ||**는 피연산자 중 왼쪽만으로 전체 결과가 결정되면 오른쪽은 평가하지 않음
> - **비트 연산자** = 피연산자 정수 값을 **비트 단위로 논리 연산**을 수행하는 연산자 
>> - 각 **피연산자를 int형으로 변환**하여 연산하며 결과도 int형임
>> - 음수의 비트 표현은 2의 보수 표현인 (보수 + 1)
>> - **보수 연산자** = ~
> - **비트 이동 연산자** = 비트 단위로 연산자의 방향으로 이동시키는 연산자
> - **비트 축약 대입 연산자** = 비트 연산과 대입 연산을 축약한 연산자
> - **형변환 연산자** = 형변환을 해주는 연산자
>> - **명시적 형변환** = 자료형 앞에 괄호를 사용해 (바꿀 자료형)을 표시 (정보 손실이 있을 수 있음)
>> - **자동 형변환** = 컴파일러에 의해 **표현 범위가 더 넓은** 자료형으로 변환

> - 연산의 **우선순위**
>> - 단항 > 산술 > 이동 > 관계 > 동등 > 비트논리 > 논리 > 조건 > 대입
>> - 관계, 동등, 논리 연산은 결과값이 boolean임
> - 산술연산 주의점
>> 1. 정수를 0으로 나누면 예외 발생, 실수인 0.0으로 나누면 무한대 출력 0.0/0.0 = NaN(Not a Number)출력
>> 2. **byte / short는 모두 int로 형변환되어 계산**되므로 다른 자료형을 계산 시 자료형을 먼저 변환시키고 계산 해야함

<h1>3장 section3 - 조건문</h1>

> - **if** = 조건의 논리 값에 따라 선택을 지원하는 구문
>> - **if (cond) stmt;** 형태임 (cond가 true면 stmt 실행 / false면 stmt 실행 안함)
>> - stmt는 여러 문장이 필요하면 블록으로도 구성 가능
> - **else** = 조건이 만족되어있지 않을때 실행하기 위해 사용
> - **else if** = if ~ else 이후에 계속 if else를 구현 할 수 있음
> - **중첩된 if** = if와 else 내부에 if 사용 가능 
>> - 조건을 나누고 if 취할때 효과적임 
>> - 이때 겉 if에는 {} 블록 사용하면 좋음
>
> ```java
> if (논리연산식1) {
>   if (논리연산식a)
>       문장1;
>   else
>       문장2;
> } else if (논리연산식2) {
>   if (논리연산식 b)
>       문장3;
>   else
>       문장4;
> }
> ```
> <br><br>
> - **switch (exp) {...}** = 표현식 exp의 결과 값 중 **case의 값과 일치하는 내부 문장**을 실행함 
>> - exp는 **기본적으로 정수형**을 허용하고 실수형 지원 X (String, Char, int, Byte, Int, short 지원)
>> - 모든 switch 문을 if 문으로 대체할 수 있으나 switch문이 효과적임
>> - **default** = 위치에 상관없이 case의 값이 일치하는 것이 없을 경우 실행 (생략 가능)
> - **switch문의 break** = 일치하는 case 실행 후 내부 문장 실행을 멈춤
>> - switch 문에서 **하나의 case에 여러 개의 정수를 콤마로 나열할 수 없으므로** 주로 break 이전에 'case x:' 형식으로 여러개 나열해둠
>
> ```java
> int ex = input.nextInt(); //String, char 등으로도 만들 수 있음
> switch (ex){
>   case 1 :
>   case 2 :
>   case 3 :
>       System.out.printf("예시 %d\n", ex);
>       break;
>   case 4: case 5 : case 6 :
>       System.out.printf("예시 %d번째\n", ex);
>       break;
>   default:
>       System.err.printf("잘못 입력하였습니다.\n")
> }
> 
> ```

<h1>4장 section1 - 제어문</h1>

> - **제어문** = 위 > 아래로 흐르는 **실행 흐름을 변형**하여 조건에 따라 실행하거나 지정된 블록을 반복하거나 또는 다른 곳으로 이동하여 실행함

<h1> 4장 section2 - 반복문 </h1>

> - **반복문** - 일정한 형태의 구문을 여러 번 실행하는 문장 (while, do while, for이 존재)
> - **while** = **while (cond) stmt;** 형식으로 사용, 반복 조건식인 cond를 평가하여 false면 문장을 종료, true면 반복몸체 stmt를 실행해 다시 cond를 평가하는 것을 반복
> ```java
> int i = 1;
> while ( i < = 10)
>   System.out.print(i++ + " ");
> 
> System.out.println();
> ```
> - **do while** = 반복 몸체 수행 후에 반복 조건을 검사함
>> - 특별한 구문이 없는 이상 do while의 몸체는 **적어도 1번**은 실행함
>> - **do {...} while;**과 같이 while 이후에 세미콜론이 필수임
> ```java
> int i = 1;
> do
>   System.out.print(i++ + " ");
> while (i <= 10);
> ``` 
> - **for** = **for (init; cond; inc) stmt;** 형식
>> - **init = 초기화, cond = 반복 수행 조건 검사, inc = 반복을 결정하는 제어문자의 증감연산을 수행**
>> - 괄호 내부의 세미콜론으로 구분되는 항목은 모두 생략이 가능하지만, 세미콜론은 2개 이상이 필수임
>> - stmt가 여러개라면 반드시 블록으로 묶어줘야 함
>> - cond 생략 = 무한 반복 / 반복조건에 이용되는 변수 i = 반복 제어변수라고 부름
>> - 반복문은 정해진 횟수만큼 반복하는데 유용함
> ```java
> int i = 1;
> for (i = 1; i <= 10; i++)
>   System.out.print(i + " ");
> 
> for (i = 1; i <= 10; sum = 0; i++)
>   sum += i;
> // = for (i=1, sum= 0; i <= 10; sum += i, i++);
> ```

> - **중첩된 반복문** = 반복문 내에 반복문이 다시 있는 구문
> ```java
> for (m = 1; m <= 4; m++) //외부 반복
> {
>   for (n = 1; n <= 3; n++)
>   ... //내부 반복
> }

> - **for / while 비교** 
>> - **for** = 주로 반복 횟수를 제어하는 제어변수 사용, 초기화와 증감부분이 있는 반복문에 적합함
>> - **while** = 반복횟수가 정해지지 않고 특정한 조건에 따라 반복을 결정하는 구문에 적합함
>> - 둘은 변환이 가능함
> - **break** = 반복문 내부에서 반복을 강제로 종료시킴
> - **continue** = 반복의 **나머지를 실행하지 않고** 다음 반복을 계속 유지함

<h1> 4장 section3 - 배열</h1>

> - **배열** = **동일한 자료형**을 정해진 수만큼 저장 처리하는 객체
> - 배열 크기(array length = 원소의 개수)가 n이면 **첨자(index)는 0 ~ n-1**까지 유효함
> - **배열은 실제 배열 객체를 가리키는 참조형임** (※ 배열명.length = 배열 속 원소의 개수 표시(배열 크기))
>> - 배열 선언에서는 절대로 배열 크기를 표시할 수 없음 (ex. int x[], double x[] 등으로만 사용함)
> - 배열 객체의 생성 = **new**를 사용하여 배열 원소를 생성해 저장이 가능함 
>> - x = new int[4] > 0인 객체가 4개 들어간 배열 생성
> - 배열 선언과 생성을 한 문장에 할 수 있음
>> ```java
>> int[] x = new int [4]
>> ```
> - **배열 원소 참조** = **배열이름[첨자]** 형식으로 사용
>> - **첨자의 범위 (0 ~ 배열크기-1)**를 벗어나면 오류 발생
> - **배열 선언 초기화** = 대입 연산자를 이용해 **중괄호 사이에 여러 원소값을 쉼표로 구분해 기술**함
> ```java
> double dScore[] = {2.78, 4.28, 3.18};//배열 크기는 기술할 수 없음
> ```
> - 배열 선언 이후의 초기화 = 초기 값을 위한 **중괄호 앞에 자료형[]**을 기술해야 함
> ```java
> int score[];
> score = new int[] {2,4,7}; // 배열 선언 이후 초기화 방법
> score = new int[] {23, 46, 78} // 다른 배열을 생성해 대입
> ```
> - **배열 복사** =  자바의 System 클래스는 배열을 쉽게 복사할 수 있는 **메소드 arraycopy()**를 제공함
> ```java
> public static void arraycopy(
> Object src, // 복사할 원본 배열
> int srcPos, // 복사할 src의 시작 첨자 위치
> Object dest, // 복사될 목적 배열
> int destPos, //복사될 dest의 시작 첨자 위치
> int leng) // 복사할 원소의 수
> ```
> - **배열 원소 출력**을 위한 for = 배열 순차출력
> ```java
> int[] copyFrom = {1,2,3,4,5,6,7};
> 
> for (int i = 0; i < copyFrom.length; i++)
>   System.out.print(copyFrom[i] + " ");
> ```
> - 더 쉽게 출력하는 **for each** = 배열 원소가 순차로 처리되며 각각 반복 시 **변수(value)에 적당한 원소 값이 저장**되어 수행됨
> ```java
> int[] copyTo = {10, 20, 30, 40, 50, 60, 70, 80};
>
> for (int value : copyTo)
>   System.out.print(value + " ");
> // for (배열 원소자료형 배열 원소가 저장되는 변수 이름 : 배열 이름) { ... value ....}
> ```

> - 다차원 배열
> - **이차원 배열** = **행과 열**의 구조로 표현 가능해 **테이블 형태의 구조 표현**에 유리
>> - 첫번째 대괄호에는 배열의 행 크기, 두번째에는 배열의 열 크기 저장
>> ```java
>> int mtrx [][];
>> mtrx = new int [2][3];
>>
>> int mtrx[][] = new int[2][3];
>> mtrx[0][0] = 3; mtrx[0][1] = 5; mtrx[0][2] = 0;
>> mtrx[1][0] = 7; mtrx[1][1] = 2; mtrx[1][2] = 8;
>> //이차원 배열의 선언과 생성을 한번에 가능
>> ```
> - 이차원 배열의 **원소 참조**
>> - mtrx[0][0]과 같이 **행과 열의 첨자를 사용**해 참조함
> - **레기드 배열** = 행마다 열의 수가 다른 들쭉날쭉한 모양의 배열
> ```java
> int ragA[][] = new int[2][]; //배열 행의 수
> ragA[0] = new int[2]; //첫번째 행의 열 수
> ragA[1] = new int[3]; // 두번째 행의 열 수
>
> int ragAry2[][];
> ragAry2 = new int[][] {{2,3}, {3,6,9}, {4,5,7,8}}
> //이차원 배열 선언 이후 초기화
> ```
> - 이차원 배열은 **중괄호를 중복적으로 사용**해 초기 값 저장이 가능하며, 래기드 배열도 **중괄호 중복 + 초기 값을 열 수에 맞도록 저장**하면 초기화가 가능함
> - **참조형 원소**를 위한 배열
> ```java
> String name [] = {"C++", "Java" , "C#"};
> ```
> - **문자열**을 위한 2차열 배열 
> ```java
> String data[][] = {{"홍","길동"},{"최","경","주"},{"Tiger","Woods"}};
> ```
> -**이차원 배열을 위한 for each** = 원소 참조를 할때, 중첩된 for each 문 사용
> ```java
> String data[][] = {{"홍","길동"},{"최","경","주"},{"Tiger","Woods"}};
> for (String ary[] : data) { //반복 시 저장될 일차원 배열을 위한 변수
>   for (String value : ary) // 반복 시 저장될 배열 원소를 위한 변수
>       System.out.print(value + " ");
>   System.out.println();
> }
> ```

> - **배열 크기 지정** = 배열 크기를 상수 뿐 아니라 **변수로도 지정이 가능함**
>> - 한번 할당된 배열 객체의 원소 수를 늘리거나 줄이는건 불가능
> ```java
> int size = 4;
> int score[] = new int[size];
> ```
> - **명령행 인자** = 프로그램 실행시 인자를 받아서 출력이 가능
>> - 메소드 main(String[] args)의 변수 args에 자료가 전달됨
> - 프로그램 Command를 실행하면서 뒤에 여러 인자를 입력하면 **문자열 배열 args에 저장**되어 프로그램에 전달됨
> ```java
> java Command 45 78 C++
> ```
